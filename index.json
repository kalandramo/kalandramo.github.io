[{"categories":["程序员必修课"],"content":"进制特点 ","date":"2023-03-06","objectID":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/:1:0","tags":["程序员基础知识"],"title":"二进制理解","uri":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/"},{"categories":["程序员必修课"],"content":"十进制的基本规则 因为：abc = a*100+b*10+c 相当于 $abc=a10^2+b10^1+c*10^0$ 如果 abc 是 110，那么就是: $110^2+110^1+0*10^0$，结果是 110 ，这明显是对的。 所以，我们可以得到结论：对于十进制来说，任意一个数字，它的大小就是各个位置的数字，乘以 10 的这个位置（从低位到高位的位置）减 1 次方的和。 ","date":"2023-03-06","objectID":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/:1:1","tags":["程序员基础知识"],"title":"二进制理解","uri":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/"},{"categories":["程序员必修课"],"content":"N进制 既然 N=10 都没毛病，那么上述结论就变成：对于 N 进制来说，任意一个数字，它的大小就是各个位置的数字，乘以 N 的这个位置（从低位到高位的位置）减 1 次方的和。 让 N=2，然后来验证下，还是 abc：$abc=a2^2+b2^1+c*2^0$ 又因为这是二进制，最大的数字就是 2-1，也就是 1，所以 abc 只能取 0 或 1。 如果 abc 是 110，那么就是: $12^2+12^1+0*2^0$，结果就是 6，搜索一下这明显也是对的。 我们看到，这跟十进制的计算没什么区别，也就是说，这个结论可以用于任何进制。 ","date":"2023-03-06","objectID":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/:1:2","tags":["程序员基础知识"],"title":"二进制理解","uri":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/"},{"categories":["程序员必修课"],"content":"进制的特点 最大数字是 N-1，大于 N 就用两位数表示；高位的数字是低位的 N 倍。 对于 N 进制来说，任意一个数字，它的大小就是各个位置的数字，乘以 N 的这个位置（从低位到高位的位置）减 1 次方的和。 ","date":"2023-03-06","objectID":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/:1:3","tags":["程序员基础知识"],"title":"二进制理解","uri":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/"},{"categories":["程序员必修课"],"content":"计算机为什么使用二进制 计算机的底层是基于晶体管实现的，可以简单地理解为一组开关，打开就表示 1，关闭就表示 0，所以，采用二进制的话，计算机只需要简单地打开/关闭这些开关即可。 ","date":"2023-03-06","objectID":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/:2:0","tags":["程序员基础知识"],"title":"二进制理解","uri":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/"},{"categories":["程序员必修课"],"content":"二进制的优点 位运算，灵活运用二进制的位运算不仅能提高速度，熟练使用二进制还能节省内存。 p q p 与 q p 或 q 0 0 0 0 1 0 0 1 0 1 0 1 1 1 1 1 我们知道：p 与 q 等于取交集，全部为 1 才为 1；p 或 q 等于取并集，全部为 0 才为 0。 OK，现在我们是二进制，只有 0 和 1。那么根据上述法则: 100∩011=000 100∪011=111。 好，那么有个问题：给定一个数 n，怎么判断 n 是不是 2 的 n 次方呢？ 很简单啊，直接求余就行了。 func is2Power(n int) bool { if n \u003c= 0 { return false } for n \u003e 1 { if n%2 != 0 { return false } n /= 2 } return true } 嗯，代码没毛病，不过不够好。看下面代码： func is2Power(n int) bool { return n \u003e 0 \u0026\u0026 n\u0026(n-1) == 0 } 我们知道，10 的 n 次方最高位是 1，其他位都是 0；2 的 n 次方也是同理。也就是说：如果一个数 a 是 2 的 n 次方，那么 a 的最高位就是 1，其他位全是 0；那么，a-1 呢，就变成高位是 0，其他位全是 1 了。 比如：a = 10000，a-1 就是 01111，根据真值表，我们知道: 10000∩01111=0 所以如果 a 是 2 的 n 次方，那么就有: a∩(a−1)=0 根据这个特性，我们只需要进行简单的按位与运算，就能很快得到正确的结果。这就是位运算的强大之处。大家可以在 leetcode 上试一下，对比下运行速度便知。 灵活运用二进制的位运算不仅能提高速度，熟练使用二进制还能节省内存。 ","date":"2023-03-06","objectID":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/:2:1","tags":["程序员基础知识"],"title":"二进制理解","uri":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/"},{"categories":["程序员必修课"],"content":"总结 N 进制的数字范围为：[0, N-1]，大于 N-1 的就要用两位数字来表示。 对于 N 进制来说，任意一个数字，它的大小就是各个位置的数字，乘以 N 的这个位置（从低位到高位的位置）减 1 次方的和。 ","date":"2023-03-06","objectID":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/:3:0","tags":["程序员基础知识"],"title":"二进制理解","uri":"/%E8%BF%9B%E5%88%B6%E7%90%86%E8%A7%A3/"},{"categories":["MySQL"],"content":"备份主库 本次采用MySQL数据库热备份工具xtrabackup进行。压缩备份用到的工具是pigz 进行压缩 MySQL数据库版本：mysql-5.7.23 xtrabackup备份工具版本：xtrabackup-2.4.12 pigz压缩工具版本：pigz-2.3.4 ","date":"2023-03-06","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/:1:0","tags":["MySQL主从"],"title":"MySQL主从结构从库重建","uri":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/"},{"categories":["MySQL"],"content":"非压缩备份 nohup $XTRABACKUP_HOME/bin/innobackupex --defaults-file=/etc/my.cfg --user=root --password=xxxxxx --socket=/etc/mysql/mysql.sock /usr/local/mysql \u003e /usr/local/mysql/backup.log 2\u003e\u00261 \u0026 nohup \u0026 后台运行备份命令 –defaults-file MySQL数据库配置文件路径 –user 备份主库使用的用户 –password 备份主库用户的密码 –socket 本地备份套接字文件路径(mysql.sock) /usr/local/mysql 备份文件存放的路径 /usr/local/mysql/backup.log 备份过程中的日志，可查看备份的执行情况 2\u003e\u00261 将标准错误重定向到标准输出 ","date":"2023-03-06","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/:1:1","tags":["MySQL主从"],"title":"MySQL主从结构从库重建","uri":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/"},{"categories":["MySQL"],"content":"压缩备份 这里的压缩备份直接将备份后的文件发送到目标主机上$remote_host nohup $XTRABACKUP_HOME/bin/innobackupex --defaults-file=/etc/my.cfg --parallel=4 --user=root --password=xxxxxx --socket=/etc/mysql/mysql.sock --slave-info --no-timestamp --stream=tar /usr/local/mysql 2\u003e /usr/local/mysql/backup.log | /iddbs/software/pigz-2.3.4/pigz -6 -p 4 | ssh $remote_host\"cat - \u003e /iddbs/tmp/backup.tar.gz\" \u0026 nohup \u0026 后台运行备份命令 –defaults-file MySQL数据库配置文件路径 –parallel 指定并行备份的线程数量 –user 备份主库使用的用户 –password 备份主库用户的密码 –socket 本地备份套接字文件路径(mysql.sock) –slave-info 该参数会在备份目录下生成xtrabackup_slave_info文件，文件记录主库的binlog日志位置点。在进行数据库恢复，搭建多从库时都需要这个文件。 –stream=tar 备份是采用的压缩方式 /usr/local/mysql 备份文件存放的路径 /usr/local/mysql/backup.log 备份过程中的日志，可查看备份的执行情况 pigz -6 -p 4 -6表示压缩级别，-p表示压缩核心数 2\u003e\u00261 将标准错误重定向到标准输出 ","date":"2023-03-06","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/:1:2","tags":["MySQL主从"],"title":"MySQL主从结构从库重建","uri":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/"},{"categories":["MySQL"],"content":"停止从库MySQL服务 先停止slave stop slave; 停止MySQL服务 $MYSQL_HOME/bin/mysqlamdin --socket=/etc/mysql/mysql.sock -uroot -pxxxxxx shutdown ","date":"2023-03-06","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/:2:0","tags":["MySQL主从"],"title":"MySQL主从结构从库重建","uri":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/"},{"categories":["MySQL"],"content":"恢复数据 恢复数据的时候，必须保证mysql数据库配置文件中datadir参数值存在且目录下为空，在进行数据恢复过程中，xtrabackup会自动将数据恢复到datadir参数值所在的目录下。 启动数据库的时候，必须保证server-id唯一。 ","date":"2023-03-06","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/:3:0","tags":["MySQL主从"],"title":"MySQL主从结构从库重建","uri":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/"},{"categories":["MySQL"],"content":"回滚日志 将主库备份好的压缩文件进行解压后执行： nohup $XTRABACKUP_HOME/bin/innobackupex --defaults-file=/etc/my.cfg --use-memory=8G --apply-log '压缩文件' \u003e/tmp/apply3306.log 2\u003e\u00261 \u0026 ","date":"2023-03-06","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/:3:1","tags":["MySQL主从"],"title":"MySQL主从结构从库重建","uri":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/"},{"categories":["MySQL"],"content":"数据恢复 nohup $XTRABACKUP_HOME/bin/innobackupex --defaults-file=/etc/my.cfg --use-memory=8G --copy-back '压缩文件' \u003e/tmp/apply3306.log 2\u003e\u00261 \u0026 ","date":"2023-03-06","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/:3:2","tags":["MySQL主从"],"title":"MySQL主从结构从库重建","uri":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/"},{"categories":["MySQL"],"content":"重做从库 启动数据库 $MYSQL_HOME/bin/mysqld_safe --defaults-file=/etc/my.cfg \u0026 查看gtid cat /usr/local/mysql/backup/xtrabackup_binlog_info /usr/local/mysql/backup 为压缩文件解压后的路径，可根据实际情况更改 在执行set global gtid_purged之前，必须执行reset master、stop slave、reset slave，否则会报错。 从库上执行： reset master; stop slave; reset slave; set global gtid_purged='71258aad-14da-11ea-8ee1-00163e0ed0aa:1-339,78599057-81e9-11e9-b25c-98039b06dd98:1-17291884,78a44d87-81e9-11e9-ae3b-98039b159cca:1-38826332,9ab6edc4-daeb-11ea-b68b-fa163e64adef:1-5,d6b50dc4-7fd2-11ea-8a35-fa163e4996e3:1-481427697'; CHANGE MASTER TO MASTER_HOST='主库IP',MASTER_PORT=mysql服务端口,MASTER_USER='主从复制账号',MASTER_PASSWORD='用户密码',MASTER_AUTO_POSITION=1; start slave show slave status\\G ","date":"2023-03-06","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/:4:0","tags":["MySQL主从"],"title":"MySQL主从结构从库重建","uri":"/mysql%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BB%8E%E5%BA%93%E9%87%8D%E5%BB%BA/"},{"categories":null,"content":"test ","date":"2023-03-06","objectID":"/first_post/:0:0","tags":null,"title":"First_post","uri":"/first_post/"}]