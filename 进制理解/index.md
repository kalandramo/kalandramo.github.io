# 二进制理解


## 进制特点

### 十进制的基本规则

因为：`abc = a*100+b*10+c`  相当于  $abc=a*10^2+b*10^1+c*10^0$

如果 abc 是 110，那么就是:  $1*10^2+1*10^1+0*10^0$，结果是 110 ，这明显是对的。

所以，我们可以得到结论：对于十进制来说，任意一个数字，它的大小就是**各个位置的数字，乘以 10 的这个位置（从低位到高位的位置）减 1 次方的和**。


### N进制
既然 N=10 都没毛病，那么上述结论就变成：对于 N 进制来说，任意一个数字，它的大小就是**各个位置的数字，乘以 N 的这个位置（从低位到高位的位置）减 1 次方的和**。

让 N=2，然后来验证下，还是 abc：$abc=a*2^2+b*2^1+c*2^0$

又因为这是二进制，最大的数字就是 2-1，也就是 1，所以 abc 只能取 0 或 1。

如果 abc 是 110，那么就是: $1*2^2+1*2^1+0*2^0$，结果就是 6，搜索一下这明显也是对的。

我们看到，这跟十进制的计算没什么区别，也就是说，这个结论可以用于任何进制。

### 进制的特点

1.  最大数字是 N-1，大于 N 就用两位数表示；高位的数字是低位的 N 倍。
2. 对于 N 进制来说，任意一个数字，它的大小就是**各个位置的数字，乘以 N 的这个位置（从低位到高位的位置）减 1 次方的和**。


## 计算机为什么使用二进制

计算机的底层是基于晶体管实现的，可以简单地理解为一组`开关`，打开就表示 1，关闭就表示 0，所以，采用二进制的话，计算机只需要简单地打开/关闭这些开关即可。

### 二进制的优点

位运算，灵活运用二进制的位运算不仅能提高速度，熟练使用二进制还能节省内存。

|p|q|p 与 q|p 或 q|
|:---:|:---:|:---:|:---:|
|0|0|0|0|
|1|0|0|1|
|0|1|0|1|
|1|1|1|1|

我们知道：p 与 q 等于取交集，全部为 1 才为 1；p 或 q 等于取并集，全部为 0 才为 0。

OK，现在我们是二进制，只有 0 和 1。那么根据上述法则:

100∩011=000 100∪011=111。

好，那么有个问题：给定一个数 n，怎么判断 n 是不是 2 的 n 次方呢？

很简单啊，直接`求余`就行了。
```go
func is2Power(n int) bool {
	if n <= 0 {
		return false
	}

	for n > 1 {
		if n%2 != 0 {
			return false
		}
		n /= 2
	}

	return true
}
```

嗯，代码没毛病，不过不够好。看下面代码：
```go
func is2Power(n int) bool {
	return n > 0 && n&(n-1) == 0
}
```

我们知道，10 的 n 次方最高位是 1，其他位都是 0；2 的 n 次方也是同理。也就是说：如果一个数 a 是 2 的 n 次方，那么 a 的最高位就是 1，其他位全是 0；那么，a-1 呢，就变成高位是 0，其他位全是 1 了。

比如：a = 10000，a-1 就是 01111，根据真值表，我们知道:
10000∩01111=0

所以如果 a 是 2 的 n 次方，那么就有:
a∩(a−1)=0

根据这个特性，我们只需要进行简单的按位与运算，就能很快得到正确的结果。这就是位运算的强大之处。大家可以在 leetcode 上试一下，对比下运行速度便知。

**灵活运用二进制的位运算不仅能提高速度，熟练使用二进制还能节省内存。**

## 总结

1.  N 进制的数字范围为：[0, N-1]，大于 N-1 的就要用两位数字来表示。
2.  对于 N 进制来说，任意一个数字，它的大小就是**各个位置的数字，乘以 N 的这个位置（从低位到高位的位置）减 1 次方的和**。
